-- one line comment
{-
   multi-line comment
   asdf
   qwerty
-}
-- За декларацията:
-- Функцията ни приема списък от неща (от тип [a])
-- и нещо (от тип а) и връща списък от неща ([a]).
-- Трябва обаче да подсигурим, че този тип може да бъде сравняван,
-- тъй като използваме (==). Това се случва чрез typeclass ограничение.
-- Непосредствено след :: изброяваме с какви типове може да работи нашата функция.
-- В случая сме длъжни да работим само с типове а, които могат да бъдат сравнявани.
-- Това значи и ограничението Eq a.
remove :: Eq a => [a] -> a -> [a]
remove [] _ = []
remove xs element = if (head xs) == element then  
  remove (tail xs) element
  else (head xs) : remove (tail xs) element

-- Втори вариант - използваме list comprehension
-- декларацията остава същата (все пак функцията ни прави същото нещо)
-- общият елемент на резултатният ни списък е `x`
-- след вертикалната черта (pipe) казваме откъде `x` последователно да приема стойности
-- в нашият случай това става от `xs`
-- след това изброяваме условия, които `x` трябва да удовлетворява, че да участва в резултатния списък
-- единственото ни условие в случая е `x` да е различен от търсения ни `element`
-- по този начин сме сигурни, че само различни от него елементи ще попаднат в резултата
remove' :: Eq a => [a] -> a -> [a]
remove' xs element = [x | x <- xs, x /= element]

-- Трети вариант - използваме вградената filter
-- вижте типа ѝ, изпълнявайки :t filter в ghci
-- накратко: приема функция и списък (както в Racket)
-- (/= element) всъщност е едноаргументна функция
-- това ще стане ясно след като прочетете глава 6 на Learn you a Haskell
remove'' :: Eq a => [a] -> a -> [a]
remove'' xs element = filter (/= element) xs

-- Последен вариант, обещавам. Използваме guards
-- guards са тези вертикални черти (pipe), които работят досущ като cond в Racket
-- тук започваме с шаблон - ако имаме празен списък, каквото и да искаме да махнем от него,
-- резултатът си остава празен списък
-- общият случай се покрива от втория шаблон - element (x:xs)
-- тук деконструираме списъка, с който е извикана функцията, на глава и опашка
-- в тялото на функцията `x` е първият елемент на списъка, а `xs` - останалите.
remove''' :: Eq a => [a] -> a -> [a]
remove''' _ [] = []
remove''' element (x:xs)
  |x == element = remove''' element xs
  |otherwise = x : remove''' element xs

-- Това сме го правили в Racket. Тук става доста по-лесно.
-- Декларацията ни казва, че очакваме списък от неща, които могат да бъдат подреждани
-- т.е. имат наредба помежду си - typeclass-ът Ord включва в себе си всички такива типове.
-- С всеки тип от Ord може да използваме функциите `>`, `<`, `>=`, `min` и т.н.
-- За повече информация, може да изпълните :info Ord
--
-- Първият шаблон се грижи за случая когато функцията е извикана с празен списък
-- Вторият - за всички останали (т.е. имаме непразен списък)
-- Казваме, че първият елемент на списъка ни ще се казва `pivot`, а опашката - `xs`.
-- Тук отново деконструираме списъка както при `remove`
-- Резултатът от функцията ни е (quicksort smaller) ++ [pivot] ++ (quicksort bigger)
-- като ++ конкатенира списъци.
-- използвайки `where` казваме какво зачат `smaller` и `bigger`, използвайки list comprehension-и
quicksort :: Ord a => [a] -> [a]
quicksort [] = []
quicksort (pivot:xs) = (quicksort smaller) ++ [pivot] ++ (quicksort bigger) -- (head xs)
    where smaller = [y | y <- xs, y < pivot]
          bigger = [y | y <- xs, y >= pivot]

average' :: [Int] -> Double -- ??

-- convert from Int to Double (or Float, or whatever is a (Num)
conv :: Int -> Double
conv x = (fromIntegral x) :: Double

-- с "fromIntegral" казваме че от "Integral" число искаме да направим някакво друго
-- и с ":: Double" казваме какъв му е типът (демек към какво искаме да го конвертираме)
--
--
-- signature for fromIntegral below
-- fromIntegral :: (Num b, Integral a) => a -> b
--
--
--
--
--
--
--

