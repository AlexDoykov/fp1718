# Haskell intro

[_Задължително_ четиво](learnyouahaskell.com)

Какво се случи:
0. Мини-мотивация за `Haskell`
1. Как да се сдобием с `Haskell` (и други полезни линкове)
2. Какво може ghci
3. *Някои* примитиви
4. Синтаксис на функции
5. (малко) Списъци

## 1. Как да се сдобием с `Haskell` (и други полезни линкове)
За Linux - `your distros package manager`

За Windows - [Цък](https://www.haskell.org/downloads)

### "Какво IDE да ползвам?"
Лично ползвам `your favourite text editor` + terminal, така че
не мога да дам мнение, но може да се разровите [тук](https://wiki.haskell.org/IDEs).

[Leksah](www.leksah.org) изглежда като да работи.

(това може и да е готина възможност да разцъкате vim например)

### [Hoogle](https://www.haskell.org/hoogle/)
Препоръчвам, когато се чудите "Има ли тази функция?" или пък
"Как се казваше тази функция?" да го ползвате. Както споменах
можете да търсите по име на функция, но също така 
и по сигнатура на функция.

## 2. Какво може ghci
Като за начало как да пуснем файл с ghci?
Можете или директно 
```
ghci asdf.hs
```
да отворите файла, или пък да пуснете ghci и в последствие да го заредите с `:load (:l)`
```
ghci
Prelude> :l asdf.hs
```
За да не трябва да отваряме и затваряме постоянно или пък
да пишем постоянно името на файла имаме `:reload (:r)`, което
действа по self-explanatory начин. Излизането от ghci
става чрез `:quit (:q)`.

Идвайки към най-якото нещо – можем да питаме ghci да ни каже
типа на някое име използвайки `:type (:t)`. Например:
```Haskell
Prelude> :t 'a'
'a' :: Char
Prelude> :t True
True :: Bool
Prelude> :t 5
5 :: Num t => t
```
#### *Важно*
Виждаме синтаксиса `X :: Y` – означава че X е от тип Y.
Последното е малко по-странно и предполагам че много скоро
ще бъде споменато на упражнение, но като цяло може да си
мислите за него като за всички типове 't', които "могат да
бъдат числа". Можем да питаме ghci и за типовете на функции,
което е по-полезната част, особено когато се опитваме да
навържем няколко подред. Не обръщайте много внимание за сега.

За функции виждаме типове със стрелкички между тях:
```Haskell
Prelude> :t id -- идентитет
id :: a -> a
Prelude> :t const -- взима два аргумента и винаги връща първия
const :: a -> b -> a
```
Какво означава това? Ами просто казано функцията връща нещо
от типа, който е след последната стрелка, а всичките останали
типове са "аргументите" ѝ. Хубаво е да направите mental note,
че всъщност всяка функция взима един аргумент, но това ще
бъде обсъдено в по-голяма дълбочина по-късно.
#### "Какъв е този тип 'a'?" (или 'b' или 't')
Когато е зададена някаква малка буквичка за тип това означава,
че може да е какъвто и да е тип. Или както се изрази един ваш
колега – "както темплейтите в C++" (но доста по-просто). 
Какво означава това за нас? В този случай можем да приложим
`id` върху _какъвто_ и тип да искаме.

Можем също така да питаме и за по-подробното `:info (:i)`,
което дава информация за къде е дефинирана някоя функция и
други подобни подробности.

## 3. *Някои* примитиви
Както видяхме по-горе имаме `Char`-ове и `Bool`-ове. Има също така
и всички нормални неща, които бихме очаквали – `Int`, `Double`,
г/д каквото се сетите. Има и такова нещо `Integer`, което
е същото като `Int`, но може да приема неограничени
стойности (доколкото ви стига RAM-та), докато `Int` е
класическото n-битово число (където n е зависимо от процесора
ви). Очевидно на него му е по-лесно да ползва `Int`-ове.

Имаме също така и прости аритметични функции каквито бихме очаквали:
```Haskell
Prelude> :t (+) -- събиране
(+) :: Num a => a -> a -> a
Prelude> :t (-) -- изваждане
(-) :: Num a => a -> a -> a
Prelude> :t (*) -- умножение
(*) :: Num a => a -> a -> a
Prelude> :t (/) -- дробно деление
(/) :: Fractional a => a -> a -> a
Prelude> :t quot -- взимане на цяла част (quotient)
quot :: Integral a => a -> a -> a
Prelude> :t rem -- взимане на остатък (remainder)
rem :: Integral a => a -> a -> a
Prelude> :t succ -- "наследник" (successor), демек +1
succ :: Enum a => a -> a
```

Можем да сравняваме неща:
```Haskell
Prelude> :t (<) 
(<) :: Ord a => a -> a -> Bool
Prelude> :t (<=)
(<=) :: Ord a => a -> a -> Bool
Prelude> :t (==)
(==) :: Eq a => a -> a -> Bool
Prelude> :t (/=) -- "различно от"
(/=) :: Eq a => a -> a -> Bool
```

## 4. Синтаксис на функции
Като за начало най-простото нещо, което можем да направим
е да декларираме нещо на интерпретатора с `let` и после
да поискаме стойността му.
```Haskell
Prelude> let a = 5
Prelude> a
5
```
Малко повече, можем по същия начин да декларираме и функции и
да ги извикваме по подобен начин.
```Haskell
Prelude> let identity x = x
Prelude> :t identity
identity :: t -> t
Prelude> identity 42
42
```
(Забележете че извикването на функция не изисква да оградим
аргументите ѝ със скоби.)
Какво казваме? Ами функцията identity взима един аргумент (x)
и връща самия него. Същото нещо с функциите и декларацията
можем да правим и в .hs документ, но там не ползваме `let` –
то е специфично за интерпретатора.
```Haskell
sumthree x y z = x + y + z
```
Както виждате можем да изпуснем типа (или сигнатурата) на
функцията, защото хората, които са правили GHC са били
достатъчно умни да се сетят, че да пишем за всичко винаги
тип (например вместо просто `5.0` да пишем `5.0 :: Double`)
и са направили нещо наречено type inference – компилаторът
може донякъде да познае типовете на нещата.
Това е много удобно, но също така е и добре познат факт,
че за всяка функция, която напишете без сигнатура, 
Бате Бобо пуска по една сълза (не искате той да плаче,
нали?). Jokes aside, писането на сигнатура МНОГО помага
да осъзнаете какво *всъщност* искате да направите и освен
това ви спира от това да пишете програми с грешни
типове (до някаква степен). За това:
```Haskell
sumthree :: Int -> Int -> Int
sumthree x y z = x + y + z
```
### ifthenelse
Очевидно за да пишем каквото и да е смислено трябва да 
можем да разклоняваме програмата си:
```Haskell
factorial :: Int -> Int
factorial x = if x == 0 then 1 else x * factorial (x - 1)
```
Не смятам за нужно да обяснявам какво прави ifthenelse конструкцията.
"Но нали каза, че не трябва да ограждаме аргументите на
функциите със скоби?"
И тук бихме настъпили една мотика. В живота някои неща са 
по-важни от други. Така и в `Haskell` – някои неща имат
по-висок приоритет. И кое е най-важното? Функциите. Очевидно.
Прилагането на функция има най-висок приоритет сред операциите
в `Haskell` и като резултат, ако напишем само 
```Haskell
factorial x - 1
```
вместо желаното от нас извикване на факториел с x - 1, ще 
получим извикване на факториел с x, от който резултат е
извадено 1.
### Guards
Нека напишем нещо друго – например втората най-любима 
студентска функция – `fib n` - връща n-тото число на от
редицата на Фибоначи.
```Haskell
fib :: Int -> Int
fib n = if n == 0 then 1
        else if n == 1 then 1
             else fib (n - 2) + fib (n - 1)
```
Както виждате не е много готино да образуваме диагонали
от `if`-ове и за това имаме друг синтаксис, който г/д
съответства на `case` в други езици. Наричат се `guards`:
```Haskell
fib' :: Int -> Int
fib' n 
    | n == 0    = 1
    | n == 1    = 1
    | otherwise = fib' (n - 2) + fib' (n - 1)
```
Ah, much better. Подравняването не е задължително, но изглежда
по-добре. Не е голям rocket science – всеки
ред с "pipe"-че на него (символа '|') дефинира
един случай от вида 
```
    | CONDITION = RESULT
```
Просто проверяваме (подред на записване отгоре-надолу)
условията и ако някое от тях е истина то тогава 
функцията взима стойността отдясно на равното. 
`otherwise` хваща всичко – сеедноче да напишем `True` там 
вместо него.

Тук е хубав момент да спомена, че 
1. В `Haskell` имат значение местата
2. `Haskell` не харесва табулациите (and the same should go for you)
За това ако всичко изглежда правилно, но не се компилира,
проверете да не би да сте объркали индентацията по някакъв начин.

#### But wait, it gets better! (for real)
### Pattern matching
Можем да напишем нещо още по-красиво
```Haskell
fib'' :: Int -> Int
fib'' 0 = 1
fib'' 1 = 1
fib'' n = fib (n - 2) + fib (n - 1)
```
К'во е т'ва? Еми това е т.нар. `pattern matching` –
ако името не ви подсказва ни позволява да зададен някакви
"шаблони", с които да се сравнят нашите аргументи. Те също
се проверяват в реда, в който са дефинирани и както и при
guard-овете връщаме това отдясно на съответния "шаблон".
Всъщност много по-лесен начин за мислене (imo) е да си мислим
че дефинираме поточково (поелементно, както искате) функцията
`fib''` (както бихме в математиката). Казваме че за
0 функцията ни е равна на 1, за 1 е равна на 1, и (за да
покрием всички останали числа)
на колко е равна за произволно число (което не е 0 или 1,
защото вече сме минали през тези случаи, без да match-нем => 
не може да е 0 или 1).


# TODO: add list docs
