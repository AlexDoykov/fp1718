-- Взима първите елементи от даден списък, за които дадено условие е изпълнено.
-- Например:
-- takeWhile' odd [1,3,5,4,2,3,1] = [1,3,5]
-- takeWhile' (< 5) [1..10] = [1,2,3,4]
takeWhile' :: (a -> Bool) -> [a] -> [a]
takeWhile' _ [] = []
takeWhile' p (x:xs)
  |p x = x : takeWhile' p xs
  |otherwise = []

-- Пропуска първите елементи от даден списък, за които дадено условие е изпълнено.
-- Например:
-- dropWhile' odd [1,3,5,4,2,3,1] = [4,2,3,1]
-- dropWhile' (< 5) [1..10] = [5,6,7,8,9,10]
-- dropWhile' (\x -> length x < 3) ["I","am","a","string","list"] = ["string", "list"]
dropWhile' :: (t -> Bool) -> [t] -> [t]
dropWhile' _ [] = []
dropWhile' p (y:ys)
  |p y = dropWhile' p ys
  |otherwise = y:ys

-- Алтернативен начин за същата функция. Използва така наречените as-patterns.
dropWhile'' :: (t -> Bool) -> [t] -> [t]
dropWhile'' _ [] = []
dropWhile'' p list@(y:ys)
  |p y = dropWhile'' p ys
  |otherwise = list
  -- Във втория шаблон казваме, че предикатът ни ще носи името 'p', а списъкът ни ще декомпозираме на глава 'y' и опашка 'ys'.
  -- list@(y:ys) дава "алтернативно" име на втория аргумент на функцията
  -- т.е. list е същото като (y:ys)
  -- ако например в някоя функция се наложи да декомпозираме списъка на първите му 4 елемента и след това опашката
  -- (x:y:z:t:xs)
  -- и след това ни се наложи някъде да използваме целия списък, ще трябва да препишем цялата тази конструкция (x:y:z:t:xs), че да го получим.
  -- Ако сложим synonym@(x:y:z:t:xs), synonym ще бъде името, което е свързано с целия списък.

-- Приема два списъка и връща списък с двойки от първите, вторите, третите и т.н. елементи на двата списъка.
-- Например:
-- zip' [1..5] [6..10] = [(1,6), (2,7), (3,8), (4,9), (5,10)]
-- Спираме когато един от двата списъка се изпразни
-- zip' [1,2] [100..200] = [(1,100), (2, 101)]
zip' :: [a] -> [b] -> [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y) : zip' xs ys

-- Приема двуаргументна функция и два списъка. 
-- Прави същото като zip, само че вместо да слага елементите в двойка (която да се превърне в елемент на резултатния списък), прилага функцията на съответните елементи и това влиза в резултатния списък
zipWith' :: (a -> b -> c) -> [a] ->[b] -> [c]
zipWith' _ _ [] = []
zipWith' _ [] _ = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys

-- имплементиране на zip чрез zipWith
zip'' :: [a] -> [b] -> [(a,b)]
zip'' xs ys = zipWith' (,) xs ys

-- вариант с частично прилагане на zipWith
zip''' :: [a] -> [b] -> [(a,b)]
zip''' = zipWith (,)

-- lessThan - приема нещо, което може да се подрежда (тоест е в Ord, тоест може да го подреждаме с <, >, <=, >=)
-- и списък от такива неща и ни връща всички елементи от списъка, които са по-малки от нашето нещо
lessThan :: Ord a => a -> [a] -> [a]
lessThan target list = filter (< target) list

-- вариант с частично прилагане на filter
lessThan' :: Ord a => a -> [a] -> [a]
lessThan' target = filter (< target)

-- everyNth - приема число (n) и списък. Връща всеки n-ти елемент от дадения списък.
-- Например:
-- everyNth 3 [1..20] = [3,6,9,12,15,18]
-- everyNth 7 [100..120] = [107,114]
everyNth :: Int -> [a] -> [a]
everyNth _ [] = []
everyNth n xs
  |n > length xs = []
  |otherwise = head (drop (n - 1) xs) : everyNth n (drop n xs)


-- втори вариант - с list comprehension
everyNth' :: Int -> [a] -> [a]
everyNth' n xs = map fst [x | x <- zip xs [1..length xs], (snd x) `mod` n == 0]
-- самият list comprehension прави списък от двойки
-- общият елемент на списъка сме кръстили x
-- той идва от zip xs [1..length xs]
-- това ни дава списък от двойки от типа
-- (елемент-на-списъка, индекс-на-елемента-в-списъка)
-- fst взима първия елемент на двойка,
-- а snd - втория
-- т.е. в list comprehension-а искаме да вземем само тези елементи, които имат индекс, кратен на n
-- накрая от върнатия списък искаме да вземем само елементите на оригиналния (без индексите, които сме сложили в list comprehension-а) и затова правим нов списък (с map), като взимаме само първият елемент от всяка двойка.

-- последен вариант.
-- Операторът !! ни дава елемент на даден индекс от списък
-- например: [10,15,12,18] !! 0 = 10
--           [10,15,12,18] !! 3 = 18
-- Интервалът [n - 1, 2 * n - 1..length xs] са всички
-- индекси, които искаме да вземем от оригиналния списък
-- Започваме от n-тия елемент (който е на n - 1 индекс) и приключваме с дължината на списъка.
-- Използвайки map, на всеки такъв индекс съпоставяме
-- съответния елемент от xs (чрез xs !!)
-- xs !! е функция, която очаква число (индекс) и ни дава съответния елемент от дадения вече като аргумент xs
--
everyNth'' :: Int -> [a] -> [a]
everyNth'' n xs = map (xs !!) [n-1,2*n-1..length xs]

-- Искам да проверя дали трите варианта на everyNth връщат един и същи резултат
-- test очаква списък от функции (ще му дадем трите everyNth) и ни казва дали резултатите след прилагане с аргументи 3 и [1..100] са еднакви.
-- За целта долу има функция allEqual, която ни казва дали в списък със сравними неща, всички са еднакви.
test :: (Enum a, Num a, Eq a) => [(Int -> [a] -> [a])] -> Bool 
test fs = allEqual $ map (($ [1..100]) . ($ 3)) fs
  where allEqual [] = True
        allEqual (x:xs) = and $ map (== x) xs
-- test = allEqual . (map (($ [1..100]) . ($ 3)))
-- прави същото

-- по-разбираем вариант на test
test' :: (Enum a, Num a, Eq a) => [(Int -> [a] -> [a])] -> Bool
test' fs = allEqual (map (\f -> f 3 [1..100]) fs)
  where allEqual [] = True
        allEqual (x:xs) = and $ map (== x) xs

areEveryNthEqual :: Bool 
areEveryNthEqual = test [everyNth, everyNth', everyNth'']

-- fun fact: не е необходимо винаги изрично да пишете типови декларации
-- Haskell може да се сети сам какви типове искате да приема вашата функция
-- Ако напишем allEqual без декларация
allEqual [] = True
allEqual (x:xs) = and $ map (== x) xs
-- и след това изпълним :t allEqual в ghci,
-- то ще ни каже
-- allEqual :: Eq a => [a] -> Bool
-- след първия ни шаблон, има как да разбере, че очакваме *някакъв* списък и връщаме Bool
-- след втория, тъй като използваме ==, вече знае, че типът трябва да е сравним
-- и това е.






