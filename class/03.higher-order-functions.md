# Трета седмица

## За какво си говорихме?

1. Какво са функциите от по-висок ред и имат ли бъдеще у нас
2. lambda изрази
3. let изрази
4. Май стига толкова - събраха се доста неща

### 1. Какво е функция от по-висок ред и защо ни е?

Функциите от по-висок ред изпълняват поне едно от следните условия:
* Приемат функции като аргументи
* Връщат функция като резултат

Q: Защо бих написал такава функция???
А: Ъм. Абстракция?

Нека имаме следните три процедури:

```Racket
(define (sum-interval start end)
  (if (> start end)
      0
      (+ start (sum-interval (+ start 1) end))
  )
)

(define (cube x) (* x x x))

(define (sum-cubes start end)
  (if (> start end)
      0
      (+ (cube start) (sum-cubes (+ start 1) end))
  )
)

(define (pi-convergent start end)
  (if (> start end)
      0
      (+ (/ 1.0 (* 2 (+ a 2))) (pi-sum (+ start 4) end))
  )
)
```

Веднага могат да се видят няколко прилики. И трите функции:
* Терминират при едно и също условие `(> start end)`
* Терминират с един и същи резултат `0`
* Едното събираемо е някаква функция на `start` (например `(cube start)`)
* Другото събираемо е рекурсивно извикване на функцията
* В рекурсивното извикване обновяваме `start` като му прилагаме някаква функция (например `(+ start 4)`)

В какво се различават? Всяка от трите функции:
* Има различно име
* Прилага се различна функция на първото събираемо
* Прилага се различна функция, която обновява `start`

Оказва се, може да *обобщим* тези три функции в една, като параметризираме разликите между тях. Например:

```Racket
(define (sum start end term next)
  (if (> start end)
      0
      (+ (term start) (sum (next start) end term next))
  )
)
```

Wow wow wow. Малко обяснение какво се случи току що:

`sum` приема 4 аргумента:
* `start` и `end` вече ги знаем - началото и края на интервала, който искаме да сумираме
* `term` - едноаргументна функция, която прилагаме върху всяко събираемо
* `next` - едноаргументна функция, с която получаваме следващото число от интервала

Ако искаме да изразим горните три функции чрез нашата нова абстракция, можем да го направим така:
```Racket
(define (inc x) (+ x 1))

(define (sum-interval start end)
  (define (id x) x)
  (sum start end id inc))

(define (sum-cubes start end)
  (define (cube x) (* x x x))
  (sum start end cube inc))
 
(define (pi-sum start end)
  (define (term x) (/ 1.0 (* 2 (+ x 2))))
  (define (next x) (+ x 4))

  (sum start end term next))
```

Какво ще се случи, когато извикаме `sum-interval`?
```Racket
(sum-interval 2 5)
(sum 2 5 id inc)
(+ (id 2) (sum (inc 2) 5 id inc))
(+ 2 (sum (inc 2) 5 id inc))
(+ 2 (sum 3 5 id inc))
(+ 2 (+ (id 3) (sum (inc 3) 5 id inc)))
(+ 2 (+ 3 (sum (inc 3) 5 id inc)))
(+ 2 (+ 3 (sum 4 5 id inc)))
(+ 2 (+ 3 (+ (id 4) (sum (inc 4) 5 id inc))))
(+ 2 (+ 3 (+ 4 (sum (inc 4) 5 id inc))))
(+ 2 (+ 3 (+ 4 (sum 5 5 id inc))))
(+ 2 (+ 3 (+ 4 (+ (id 5) (sum (inc 5) 5 id inc)))))
(+ 2 (+ 3 (+ 4 (+ 5 (sum (inc 5) 5 id inc)))))
(+ 2 (+ 3 (+ 4 (+ 5 (sum 6 5 id inc)))))
(+ 2 (+ 3 (+ 4 (+ 5 0))))
...
14
```

#### В Scheme функциите са данни.
Това ще рече, че спокойно можем да ги подаваме като аргументи на функции.
Спокойно можем да ги връщаме като резултат от функции.
